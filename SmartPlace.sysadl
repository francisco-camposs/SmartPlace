Model SysADLModel ; package SmartPlaceDUD {  unit Celsius { dimension = Temperatura } dimension Temperatura } Requirement RequisitosSmartPlace ( 0 ) { text = "o Sistema deve satisfazer os requisitos funcionais e não funcionais." } Requirement GerenciarLugarFR ( 1 ) { text = "O sistema deve ser capaz de gerenciar os ar-condicionados e as luzes da sala baseados nos dados de presença." derive RequisitosSmartPlace ;    }  Requirement QualidadeNFR ( 2 ) { text = "O sistema deve satisfazer os requisitos de disponibilidade e modificabilidade." derive RequisitosSmartPlace ;   } Requirement MonitoramentoWebFR ( 3 ) { text = "O sistema deve ser capaz exibir o status dos ar-condicionados e os dados de presença em uma interface web." derive RequisitosSmartPlace ;   } package SmartPlaceVLD { enum ComandosLampada { ligar_luzes , desligar_luzes } enum CommandosArCondicionado { ligar_ar_condicionado , desligar_ar_condicionado , definir_temperatura } value type Boolean { } value type Int { } value type String { } value type Real { } value type Void { } value type TemperaturaCelsius { unit = SmartPlaceDUD.Celsius } datatype ArCondicionadoComando { attributes : arCondicionado : CommandosArCondicionado ; } datatype LampadaComando { attributes : lampada : ComandosLampada ; }  value type Video { } enum StatusEquipamento { ligado , desligado , danificado } datatype DadosPresenca { attributes : alguemPresente : Boolean ; quantidadePessoas : Int ; } } package SmartPlacePTD { import SmartPlaceVLD ; port def ComandoArCondicionadoIPT { flow in ArCondicionadoComando } port def ComandoArCondicionadoOPT { flow out CommandosArCondicionado } port def ComandoLampadaIPT { flow in LampadaComando } port def ComandoLampadaOPT { flow out LampadaComando } port def QuantidadePessoasIPT { flow in Int }  port def AlguemPresenteIPT { flow in Boolean }    port def CelsiusIPT { flow in TemperaturaCelsius }    port def VideoIPT { flow in Video } port def VideoOPT { flow out Video } port def StatusArCondicionadoIPT { flow in StatusEquipamento } port def QuantidadePessoasOPT { flow out Int } port def AlguemPresenteOPT { flow out Boolean }  port def CelsiusOPT { flow out TemperaturaCelsius }   port def DadosPresencaIPT { flow in DadosPresenca } port def DadosPresencaOPT { flow out DadosPresenca } port def StatusArCondicionadoOPT { flow out StatusEquipamento } } package SmartPlaceCND { import SmartPlacePTD ; connector def ComandosArCondicionadoCN { participants : ~ comandoArCondicionadoIPT1 : ComandoArCondicionadoIPT ; ~ comandoArCondicionadoOPT1 : ComandoArCondicionadoOPT ; flows : ArCondicionadoComando from comandoArCondicionadoIPT1 to comandoArCondicionadoOPT1 } connector def ComandosLampadaCN { participants : ~ comandoLampadaIPT1 : ComandoLampadaIPT ; ~ comandoLampadaOPT1 : ComandoLampadaOPT ; flows : LampadaComando from comandoLampadaIPT1 to comandoLampadaOPT1 }    connector def ArCondicionadoStatus { participants : ~ statusArCondicionadoIPT1 : StatusArCondicionadoIPT ; ~ statusArCondicionadoOPT1 : StatusArCondicionadoOPT ; flows : StatusEquipamento from statusArCondicionadoIPT1 to statusArCondicionadoOPT1 }  connector def VideoCN { participants : ~ videoIPT1 : VideoIPT ; ~ videoOPT1 : VideoOPT ; flows : Video from videoIPT1 to videoOPT1 }  connector def QuantidadePessoasCN { participants : ~ quantidadePessoasIPT1 : QuantidadePessoasIPT ; ~ quantidadePessoasOPT1 : QuantidadePessoasOPT ; flows : Int from quantidadePessoasIPT1 to quantidadePessoasOPT1 } connector def DadosPresencaCN { participants :         ~ dadosPresencaOPT : DadosPresencaOPT ;    ~ dadosPresencaIPT : DadosPresencaIPT ; flows : DadosPresenca from dadosPresencaIPT to dadosPresencaOPT }  connector def AlguemPresenteCN { participants : ~ alguemPresenteIPT1 : AlguemPresenteIPT ; ~ alguemPresenteOPT1 : AlguemPresenteOPT ; flows : Boolean from alguemPresenteIPT1 to alguemPresenteOPT1 }  connector def CelciusCN { participants : ~ celsciusIPT1 : CelsiusIPT ; ~ CelciusOPT1 : CelsiusOPT ; flows : TemperaturaCelsius from celsciusIPT1 to CelciusOPT1 } } package SmartPlaceCPD { import SmartPlaceCND ; import SmartPlacePTD ; boundary
	component def CameraCP { ports : videoOPT : VideoOPT ; } boundary
	component def SensorDePresencaCP { ports : sensorPresencaOPT : AlguemPresenteOPT ; } boundary
	component def LeitorDeTemperaturaCP { ports :  celsciusOPT : CelsiusOPT ; } boundary
	component def InterfaceWebCP { ports :    statusArCondicionadoIPT : StatusArCondicionadoIPT ; dadosPresencaIPT : DadosPresencaIPT ; } boundary
	component def ArCondicionadoCP { ports : comandoArCondicionadoIPT : ComandoArCondicionadoIPT ; statusArCondicionadoOPT : StatusArCondicionadoOPT ; temperaturaIPT : CelsiusIPT ; } boundary
	component def LampadasCP { ports : ComandoLampadaIPT : ComandoLampadaIPT ; }
	component def ControladorPresencaCP { ports : videoIPT2 : VideoIPT ; sensorIPT1 : AlguemPresenteIPT ; dadosPresencaOPT1 : DadosPresencaOPT ; }
	component def ServidorWebCP { ports : statusArCondicionadoIPT : StatusArCondicionadoIPT ; statusArCondicionadoOPT1 : StatusArCondicionadoOPT ; dadosPresencaIPT2 : DadosPresencaIPT ; dadosPresencaOPT : DadosPresencaOPT ; }
	component def ControladorLampadaCP { ports : comandoLampadaOPT1 : ComandoLampadaOPT ; dadosPresencaIPT1 : DadosPresencaIPT ; }
	component def ControladorArCondicionado { ports : statusArCondicionadoIPT1 : StatusArCondicionadoIPT ; arCondicionadoComandoOPT1 : ComandoArCondicionadoOPT ; statusArCondicionadoOPT1 : StatusArCondicionadoOPT ; celsiusOPT1 : CelsiusOPT ; celciusIPT1 : CelsiusIPT ; dadosPresencaIPT1 : DadosPresencaIPT ; }
	component def SistemaSmartPlace { ports : celsiusIPT : CelsiusIPT ; alguemPresenteIPT : AlguemPresenteIPT ; videoIPT : VideoIPT ; statusACOPT : StatusArCondicionadoOPT ; dadosPresencaOPT : DadosPresencaOPT ; statusACIPT : StatusArCondicionadoIPT ; celsiusOPT : CelsiusOPT ; comandoLampadaOPT : ComandoLampadaOPT ; comandoACOPT : ComandoArCondicionadoOPT ; configuration { components : ControladorArCondicionado : ControladorArCondicionado { using ports : statusArCondicionadoIPT1 : StatusArCondicionadoIPT ; arCondicionadoComandoOPT1 : ComandoArCondicionadoOPT ; statusArCondicionadoOPT1 : StatusArCondicionadoOPT ; celsiusOPT1 : CelsiusOPT ; celciusIPT1 : CelsiusIPT ; dadosPresencaIPT1 : DadosPresencaIPT ; } ControladorLampadaCP : ControladorLampadaCP { using ports : comandoLampadaOPT1 : ComandoLampadaOPT ; dadosPresencaIPT3 : DadosPresencaIPT ; } ServidorWebCP : ServidorWebCP { using ports : statusArCondicionadoIPT2 : StatusArCondicionadoIPT ; statusArCondicionadoOPT2 : StatusArCondicionadoOPT ; dadosPresencaIPT2 : DadosPresencaIPT ; dadosPresencaOPT2 : DadosPresencaOPT ; } ControladorPresencaCP : ControladorPresencaCP { using ports : videoIPT2 : VideoIPT ; sensorIPT1 : AlguemPresenteIPT ; dadosPresencaOPT1 : DadosPresencaOPT ; } connectors : dadosPresencaCN1 : DadosPresencaCN bindings dadosPresencaOPT1 = dadosPresencaIPT2 ; dadosPresencaCN2 : DadosPresencaCN bindings dadosPresencaOPT1 = dadosPresencaIPT1 ; statusACCN2 : ArCondicionadoStatus bindings statusArCondicionadoOPT1 = statusArCondicionadoIPT2 ; dadosPresencaCn3 : DadosPresencaCN bindings dadosPresencaOPT1 = dadosPresencaIPT3 ; delegations : comandoLampadaOPT1 to comandoLampadaOPT videoIPT2 to videoIPT sensorIPT1 to alguemPresenteIPT dadosPresencaOPT2 to dadosPresencaOPT statusArCondicionadoIPT1 to statusACIPT celciusIPT1 to celsiusIPT arCondicionadoComandoOPT1 to comandoACOPT celsiusOPT1 to celsiusOPT statusArCondicionadoOPT2 to statusACOPT } }
	component def SmartPlace { configuration { components : ArCondicionadoCP : ArCondicionadoCP { using ports : comandoArCondicionadoIPT : ComandoArCondicionadoIPT ; statusArCondicionadoOPT : StatusArCondicionadoOPT ; temperaturaIPT : CelsiusIPT ; } CameraCP : CameraCP { using ports : videoOPT : VideoOPT ; } InterfaceWebCP : InterfaceWebCP { using ports : statusArCondicionadoIPT : StatusArCondicionadoIPT ; dadosPresencaIPT : DadosPresencaIPT ; } LampadasCP : LampadasCP { using ports : ComandoLampadaIPT : ComandoLampadaIPT ; } LeitorDeTemperaturaCP : LeitorDeTemperaturaCP { using ports : celsciusOPT : CelsiusOPT ; } SensorDePresencaCP : SensorDePresencaCP { using ports : sensorPresencaOPT : AlguemPresenteOPT ; } SistemaSmartPlace : SistemaSmartPlace { using ports : celsiusIPT : CelsiusIPT ; alguemPresenteIPT : AlguemPresenteIPT ; videoIPT : VideoIPT ; statusACOPT : StatusArCondicionadoOPT ; dadosPresencaOPT : DadosPresencaOPT ; statusACIPT : StatusArCondicionadoIPT ; celsiusOPT : CelsiusOPT ; comandoLampadaOPT : ComandoLampadaOPT ; comandoACOPT : ComandoArCondicionadoOPT ; } connectors : celsiusOPT : CelciusCN bindings celsiusOPT = temperaturaIPT ; statusAC : ArCondicionadoStatus bindings statusACIPT = statusArCondicionadoOPT ; comandoACCN : ComandosArCondicionadoCN bindings comandoACOPT = comandoArCondicionadoIPT ; comandosLampadaCN : ComandosLampadaCN bindings comandoLampadaOPT = ComandoLampadaIPT ; statusACCN : ArCondicionadoStatus bindings statusACOPT = statusArCondicionadoIPT ; dadosPresencaCN : DadosPresencaCN bindings dadosPresencaOPT = dadosPresencaIPT ; alguemPresenteCN : AlguemPresenteCN bindings sensorPresencaOPT = alguemPresenteIPT ; celsiusCN : CelciusCN bindings celsciusOPT = celsiusIPT ; videoCN : VideoCN bindings videoOPT = videoIPT ; } } } Requirement ProcessamentoVideoFR ( 1.3.2.1 ) { text = "O sistema deve ser capaz de processar um stream vídeo  para calcular o número de pessoas nele." derive ContarPessoasFR ; } Requirement ControlarArCondicionadoFR ( 1.1.1 ) { text = "O sistema deve ser capaz de ligar e desligar o ar-condicionado baseado nos dados de presença." derive GerenciarArCondicionadoFR ; } Requirement ControlarTemperaturaFR ( 1.1.3 ) { text = "O sistema deve ser capaz de definir a temperatura do ar-condicionado baseada no dado do leitor de temperatura." derive GerenciarArCondicionadoFR ; } Requirement GerenciarArCondicionadoFR ( 1.1 ) { text = "O sistema deve ser capaz de controlar o ar-condicionado." derive GerenciarLugarFR ; } Requirement GerenciarLuzesFR ( 1.2 ) { text = "O Sistema deve ser capaz de ligar e desligar as luzes baseados nos dados de presença." derive GerenciarLugarFR ; } Requirement DetectarPresencaFR ( 1.3.1 ) { text = "O sistema deve ser capaz de receber dados de um sensor de presença para detectar a presença de pessoas na sala." derive DetectarPessoasFR ; } Requirement ContarPessoasFR ( 1.3.2 ) { text = "O sistema deve ser capaz de receber e processar os dados de entrada de uma camera para contar a quantidade de pessoas na sala." derive DetectarPessoasFR ; } Requirement DetectarPessoasFR ( 1.3 ) { text = "O sistema deve ser capaz de  detectar a presença e contar a quantidade de pessoas na sala." derive GerenciarLugarFR ; } Requirement VerificarAparelhosFR ( 3.1 ) { text = "O sistema deve ser capaz de verificar o status do ar-condicionado." derive MonitoramentoWebFR ; } Requirement InterfaceWebFR ( 3.2 ) { text = "O sistema deve possuir uma interface web." derive MonitoramentoWebFR ; } Requirement ModificabilidadeNFR ( 2.2 ) { text = "O sistema deve ser extensível para novas formas de detecção de presença." derive QualidadeNFR ; } Requirement ModificabilidadeNFR ( 2.2.1 ) { text = "O sistema deve ser extensível para novas formas de detecção de presença." derive QualidadeNFR ; } Requirement ReceberVideoFR ( 1.3.2.2 ) { text = "O sistema deve ser capaz de receber um stream de video da camera." derive ContarPessoasFR ; }  Requirement LerTemperaturaFR ( 1.1.2 ) { text = "O sistema deve ser capaz de definir a temperatura do ar-condicionado a partir do leitor na sala." derive GerenciarArCondicionadoFR ; } Requirement LerLeitor ( 1.1.2.1 ) { text = "O sistema deve ser capaz de ler a temperatura em Celcius e Farenheit do leito na sala." derive LerTemperaturaFR ; }  style IoTStyle { invariant checkSensorCP = "self.checkCPRecursive(self, \'SensorCP\')" invariant checkDataStoreCP = "self.checkCPRecursive(self, \'DataStoreCP\')" invariant checkDeviceCP = "self.checkCPRecursive(self, \'DeviceCP\')" invariant checkSensorOPT = "self.checkPTRecursive(self, \'SensorOPT\')" invariant checkActuatorIPT = "not (self.checkCPRecursive(self, \'ActuatorCP\') xor self.checkPTRecursive(self, \'ActuatorIPT\'))" invariant checkDataIPT = "self.checkPTRecursive(self, \'DataIPT\')" invariant checkDataOPT = "self.checkPTRecursive(self, \'DataOPT\')" invariant checkServiceOPT = "not (self.checkCPRecursive(self, \'GatewayCP\') xor self.checkPTRecursive(self, \'ServiceOPT\'))" invariant checkDeviceIPT = "not (self.checkCPRecursive(self, \'GatewayCP\') xor self.checkPTRecursive(self, \'DeviceIPT\'))" invariant checkSensorDataCN = "self.checkCNRecursive(self, \'SensorDataCN\')" invariant checkDataStoreCN = "self.checkCNRecursive(self, \'DataStoreCN\')" invariant checkActuatorCommandCN = "not (self.checkCPRecursive(self, \'ActuatorCP\') xor self.checkCNRecursive(self, \'ActuatorCommandCN\'))" invariant checkServiceCN = "not (self.checkCPRecursive(self, \'GatewayCP\') xor self.checkCNRecursive(self, \'ServiceCN\'))" invariant checkDeviceDataCN = "not (self.checkPTRecursive(self, \'DeviceOPT\') xor self.checkCNRecursive(self, \'DeviceDataCN\'))" invariant ControllerMustBeEmbeddedInDevice = "self.ControllerCPEmbedded(self)" invariant SensorMustBeConnectedToDeviceOrController = "self.SensorConnection(self)" invariant ActuatorMustBeConnectedToDeviceOrController = "self.ActuatorConnection(self)" invariant SensorAndActuatorDontCommunicate = "self.Communication(self)" invariant SensorDataCNMustNotBeMultiplex = "self.checkBindingsRecursive(self, \'SensorDataCN\')" invariant ActuatorCommandCNMustNotBeMultiplex = "self.checkBindingsRecursive(self, \'ActuatorCommandCN\')" invariant DeviceDataCNMustNotBeMultiplex = "self.checkBindingsRecursive(self, \'DeviceDataCN\')" abstract component def SensorCP [ 1 , -1 ] { ports : SensorOPT : out any [ 1 , -1 ] } abstract component def ActuatorCP [ 0 , -1 ] { ports : ActuatorIPT : in any [ 1 , -1 ] } abstract component def DeviceCP [ 1 , -1 ] { ports : DeviceOPT : out any [ 0 , -1 ] SensorIPT : in any [ 0 , -1 ] ActuatorOPT : out any [ 0 , -1 ] ServiceIPT : in any [ 0 , -1 ] compose { SensorCP , ActuatorCP , ControllerCP , GatewayCP , DataStoreCP } } abstract component def DataStoreCP [ 1 , -1 ] { ports : DataOPT : out any [ 1 , -1 ] DataIPT : in any [ 1 , -1 ] } abstract component def ControllerCP [ 0 , -1 ] { ports : SensorIPT : in any [ 0 , -1 ] ActuatorOPT : out any [ 0 , -1 ] } abstract component def GatewayCP [ 0 , -1 ] { ports : DeviceIPT : in any [ 1 , -1 ] ServiceOPT : out any [ 1 , -1 ] ServiceIPT : in any [ 0 , -1 ] compose { DataStoreCP } } abstract component def IoTARCH { compose { SensorCP , ActuatorCP , DeviceCP , GatewayCP , DataStoreCP } } abstract connector def SensorDataCN { participants : ~ SensorOPT : out any ~ SensorIPT : in any flows : flow SensorOPT to SensorIPT } abstract connector def ActuatorCommandCN { participants : ~ ActuatorOPT : out any ~ ActuatorIPT : in any flows : flow ActuatorOPT to ActuatorIPT } abstract connector def DeviceDataCN { participants : ~ DeviceOPT : out any ~ DeviceIPT : in any flows : flow DeviceOPT to DeviceIPT } abstract connector def DataStoreCN { participants : ~ DataOPT : out any ~ DataIPT : in any flows : flow DataOPT to DataIPT } abstract connector def ServiceCN { participants : ~ ServiceOPT : out any ~ ServiceIPT : in any flows : flow ServiceOPT to ServiceIPT } abstract activity def Monitoring abstract activity def Analysis abstract activity def Planning abstract activity def Execution } style PipesFilters { invariant OnlyPipesConnectsFilters = "self.connectors->forall(cn | cn.definition.abstractConnector.name<>\'APipe\' or (cn.definition.abstractConnector.name=\'APipe\' and (checkPortUseAbstractComponent(cn.bindings->first().destination,\'AFilter\') and checkPortUseAbstractComponent(cn.bindings->first().source, \'AFilter\'))))" abstract connector def APipe { } abstract component def AFilter { } } style ClientServer { invariant ClientMustConnectToServer = "self.ExistsConnectionForAll(\'AClient\', \'AServer\')" invariant ClientShouldntConnectToClient = "not(self.ExistsConnection(\'AClient\', \'AClient\'))" abstract component def AClient { } abstract component def AServer { } }