Model SysADLModel ; package SmartPlaceDUD {  unit Celsius { dimension = Temperatura } dimension Temperatura } Requirement RequisitosSmartPlace ( 0 ) { text = "o Sistema deve satisfazer os requisitos funcionais e não funcionais." } Requirement GerenciarLugarFR ( 1 ) { text = "O sistema deve ser capaz de gerenciar os ar-condicionados e as luzes da sala baseados nos dados de presença." derive RequisitosSmartPlace ;    }  Requirement QualidadeNFR ( 2 ) { text = "O sistema deve satisfazer os requisitos de disponibilidade e modificabilidade." derive RequisitosSmartPlace ;   } Requirement MonitoramentoWebFR ( 3 ) { text = "O sistema deve ser capaz exibir o status dos ar-condicionados e os dados de presença em uma interface web." derive RequisitosSmartPlace ;   } package SmartPlaceVLD { enum CmdLampada { ligar_luzes , desligar_luzes } enum CommandoAC { ligar_ar_condicionado , desligar_ar_condicionado , definir_temperatura } value type Boolean { } value type Int { } value type String { } value type Real { } value type Void { } value type TemperaturaCelsius { unit = SmartPlaceDUD.Celsius } datatype ComandoAC { attributes : arCondicionado : CommandoAC ; } datatype LampadaCmd { attributes : lampada : CmdLampada ; }  value type Video { } enum StatusEquipamento { ligado , desligado , danificado } datatype DadosPresenca { attributes : alguemPresente : Boolean ; quantidadePessoas : Int ; } } package SmartPlacePTD { import SmartPlaceVLD ; port def ComandoACIPT { flow in ComandoAC } port def ComandoACOPT { flow out CommandoAC } port def CmdLampadaIPT { flow in LampadaCmd } port def CmdLampadaOPT { flow out LampadaCmd } port def QtndPessoasIPT { flow in Int }  port def AlguemPresenteIPT { flow in Boolean }    port def CelsiusIPT { flow in TemperaturaCelsius }    port def VideoIPT { flow in Video } port def VideoOPT { flow out Video } port def StatusACIPT { flow in StatusEquipamento } port def QtndPessoasOPT { flow out Int } port def AlguemPresenteOPT { flow out Boolean }  port def CelsiusOPT { flow out TemperaturaCelsius }   port def DadosPresencaIPT { flow in DadosPresenca } port def DadosPresencaOPT { flow out DadosPresenca } port def StatusACOPT { flow out StatusEquipamento } } package SmartPlaceCND { import SmartPlacePTD ; connector def ComandoACCN { participants : ~ comandoArCondicionadoIPT1 : ComandoACIPT ; ~ comandoArCondicionadoOPT1 : ComandoACOPT ; flows : ComandoAC from comandoArCondicionadoIPT1 to comandoArCondicionadoOPT1 } connector def CmdLampadaCN { participants : ~ comandoLampadaIPT1 : CmdLampadaIPT ; ~ comandoLampadaOPT1 : CmdLampadaOPT ; flows : LampadaCmd from comandoLampadaIPT1 to comandoLampadaOPT1 }    connector def ACStatusCN { participants : ~ statusArCondicionadoIPT1 : StatusACIPT ; ~ statusArCondicionadoOPT1 : StatusACOPT ; flows : StatusEquipamento from statusArCondicionadoIPT1 to statusArCondicionadoOPT1 }  connector def VideoCN { participants : ~ videoIPT1 : VideoIPT ; ~ videoOPT1 : VideoOPT ; flows : Video from videoIPT1 to videoOPT1 }  connector def QtndPessoasCN { participants : ~ quantidadePessoasIPT1 : QtndPessoasIPT ; ~ quantidadePessoasOPT1 : QtndPessoasOPT ; flows : Int from quantidadePessoasIPT1 to quantidadePessoasOPT1 } connector def DadosPresencaCN { participants :         ~ dadosPresencaOPT : DadosPresencaOPT ;    ~ dadosPresencaIPT : DadosPresencaIPT ; flows : DadosPresenca from dadosPresencaIPT to dadosPresencaOPT }  connector def AlguemPresenteCN { participants : ~ alguemPresenteIPT1 : AlguemPresenteIPT ; ~ alguemPresenteOPT1 : AlguemPresenteOPT ; flows : Boolean from alguemPresenteIPT1 to alguemPresenteOPT1 }  connector def CelciusCN { participants : ~ celsciusIPT1 : CelsiusIPT ; ~ CelciusOPT1 : CelsiusOPT ; flows : TemperaturaCelsius from celsciusIPT1 to CelciusOPT1 } } package SmartPlaceCPD { import SmartPlaceCND ; import SmartPlacePTD ; import SmartPlaceVLD ; boundary
	component def CameraBCP { ports : videoOPT : VideoOPT ; } boundary
	component def SensorDePresencaBCP { ports : sensorPresencaOPT : AlguemPresenteOPT ; } boundary
	component def LeitorDeTemperaturaBCP { ports :  celsciusOPT : CelsiusOPT ; } boundary
	component def InterfaceWebBCP { ports :    statusACIPT : StatusACIPT ; dadosPresencaIPT : DadosPresencaIPT ; } boundary
	component def ArCondicionadoBCP { ports : comandoACIPT : ComandoACIPT ; statusACOPT : StatusACOPT ; temperaturaIPT : CelsiusIPT ; } boundary
	component def LampadasBCP { ports : cmdLampadaIPT : CmdLampadaIPT ; }
	component def ControladorPresencaCP { ports : videoIPT2 : VideoIPT ; sensorIPT1 : AlguemPresenteIPT ; dadosPresencaOPT1 : DadosPresencaOPT ; configuration { components : ModuloPresencaCP : ModuloPresencaCP { using ports : qtndPessoa : QtndPessoasIPT ; presenca : AlguemPresenteIPT ; dadoPresenca : DadosPresencaOPT ; } ProcessadorDeVideoMLCP : ProcessadorDeVideoMLCP { using ports : videoIPT : VideoIPT ; qtndPessoasOPT : QtndPessoasOPT ; } connectors : qtndPessoasCN : QtndPessoasCN bindings qtndPessoasOPT = qtndPessoa ; delegations : videoIPT to videoIPT2 dadoPresenca to dadosPresencaOPT1 presenca to sensorIPT1 } }
	component def ServidorWebCP { ports : statusACIPT : StatusACIPT ; statusACOPT1 : StatusACOPT ; dadosPresencaIPT2 : DadosPresencaIPT ; dadosPresencaOPT : DadosPresencaOPT ; }
	component def ControladorLampadaCP { ports : cmdLampadaOPT1 : CmdLampadaOPT ; dadosPresencaIPT1 : DadosPresencaIPT ; }
	component def ControladorArCondicionadoCP { ports : statusACIPT : StatusACIPT ; ACComandoOPT1 : ComandoACOPT ; statusACOPT1 : StatusACOPT ; celsiusOPT1 : CelsiusOPT ; celciusIPT1 : CelsiusIPT ; dadosPresencaIPT1 : DadosPresencaIPT ; configuration { components : ModuloMonitoramentoACCP : ModuloMonitoramentoACCP { using ports : statusACIPT : StatusACIPT ; statusACOPT : StatusACOPT ; } ModuloControleACCP : ModuloControleACCP { using ports : presencaIPT : DadosPresencaIPT ; comandoACOPT : ComandoACOPT ; temperaturaOPT : CelsiusOPT ; temperaturaIPT : CelsiusIPT ; } delegations : statusACIPT to statusACIPT statusACOPT to statusACOPT1 presencaIPT to dadosPresencaIPT1 temperaturaIPT to celciusIPT1 comandoACOPT to celsiusOPT1 temperaturaOPT to ACComandoOPT1 } }
	component def SistemaSmartPlace { ports : celsiusIPT : CelsiusIPT ; alguemPresenteIPT : AlguemPresenteIPT ; videoIPT : VideoIPT ; statusACOPT : StatusACOPT ; dadosPresencaOPT : DadosPresencaOPT ; statusACIPT : StatusACIPT ; celsiusOPT : CelsiusOPT ; cmdLampadaOPT : CmdLampadaOPT ; comandoACOPT : ComandoACOPT ; configuration { components : ControladorArCondicionado : ControladorArCondicionadoCP { using ports : statusArCondicionadoIPT1 : StatusACIPT ; arCondicionadoComandoOPT1 : ComandoACOPT ; statusArCondicionadoOPT1 : StatusACOPT ; celsiusOPT1 : CelsiusOPT ; celciusIPT1 : CelsiusIPT ; dadosPresencaIPT1 : DadosPresencaIPT ; } ControladorLampadaCP : ControladorLampadaCP { using ports : comandoLampadaOPT1 : CmdLampadaOPT ; dadosPresencaIPT3 : DadosPresencaIPT ; } ServidorWebCP : ServidorWebCP { using ports : statusArCondicionadoIPT2 : StatusACIPT ; statusArCondicionadoOPT2 : StatusACOPT ; dadosPresencaIPT2 : DadosPresencaIPT ; dadosPresencaOPT2 : DadosPresencaOPT ; } ControladorPresencaCP : ControladorPresencaCP { using ports : videoIPT2 : VideoIPT ; sensorIPT1 : AlguemPresenteIPT ; dadosPresencaOPT1 : DadosPresencaOPT ; } connectors : dadosPresencaCN1 : DadosPresencaCN bindings dadosPresencaOPT1 = dadosPresencaIPT2 ; dadosPresencaCN2 : DadosPresencaCN bindings dadosPresencaOPT1 = dadosPresencaIPT1 ; statusACCN2 : ACStatusCN bindings statusArCondicionadoOPT1 = statusArCondicionadoIPT2 ; dadosPresencaCn3 : DadosPresencaCN bindings dadosPresencaOPT1 = dadosPresencaIPT3 ; delegations : comandoLampadaOPT1 to cmdLampadaOPT videoIPT2 to videoIPT sensorIPT1 to alguemPresenteIPT dadosPresencaOPT2 to dadosPresencaOPT statusArCondicionadoIPT1 to statusACIPT celciusIPT1 to celsiusIPT arCondicionadoComandoOPT1 to comandoACOPT celsiusOPT1 to celsiusOPT statusArCondicionadoOPT2 to statusACOPT } }
	component def SmartPlace { configuration { components : ArCondicionadoCP : ArCondicionadoBCP { using ports : comandoArCondicionadoIPT : ComandoACIPT ; statusArCondicionadoOPT : StatusACOPT ; temperaturaIPT : CelsiusIPT ; } CameraCP : CameraBCP { using ports : videoOPT : VideoOPT ; } InterfaceWebCP : InterfaceWebBCP { using ports : statusArCondicionadoIPT : StatusACIPT ; dadosPresencaIPT : DadosPresencaIPT ; } LampadasCP : LampadasBCP { using ports : ComandoLampadaIPT : CmdLampadaIPT ; } LeitorDeTemperaturaCP : LeitorDeTemperaturaBCP { using ports : celsciusOPT : CelsiusOPT ; } SensorDePresencaCP : SensorDePresencaBCP { using ports : sensorPresencaOPT : AlguemPresenteOPT ; } SistemaSmartPlace : SistemaSmartPlace { using ports : celsiusIPT : CelsiusIPT ; alguemPresenteIPT : AlguemPresenteIPT ; videoIPT : VideoIPT ; statusACOPT : StatusACOPT ; dadosPresencaOPT : DadosPresencaOPT ; statusACIPT : StatusACIPT ; celsiusOPT : CelsiusOPT ; comandoLampadaOPT : CmdLampadaOPT ; comandoACOPT : ComandoACOPT ; } connectors : celsiusOPT : CelciusCN bindings celsiusOPT = temperaturaIPT ; statusAC : ACStatusCN bindings statusACIPT = statusArCondicionadoOPT ; comandoACCN : ComandoACCN bindings comandoACOPT = comandoArCondicionadoIPT ; comandosLampadaCN : CmdLampadaCN bindings comandoLampadaOPT = ComandoLampadaIPT ; statusACCN : ACStatusCN bindings statusACOPT = statusArCondicionadoIPT ; dadosPresencaCN : DadosPresencaCN bindings dadosPresencaOPT = dadosPresencaIPT ; alguemPresenteCN : AlguemPresenteCN bindings sensorPresencaOPT = alguemPresenteIPT ; celsiusCN : CelciusCN bindings celsciusOPT = celsiusIPT ; videoCN : VideoCN bindings videoOPT = videoIPT ; } } component def ProcessadorDeVideoMLCP { ports : videoIPT : VideoIPT ; qtndPessoasOPT : QtndPessoasOPT ; }
	 activity def ControladorLampadaAC ( dadosPresenca : DadosPresenca ) : ( comandoLampada : CmdLampada ) { body { actions : DefinirEstadoLampadaAC : DefinirEstadoLampadaAC { using pins : presenca : DadosPresenca ; } } } action def DefinirEstadoLampadaAC ( presenca : DadosPresenca ) : LampadaCmd { constraint : pre-condition DefinirEstadoLampadaEQ delegate presenca to dadoPresenca delegate DefinirEstadoLampadaAC to comando } 
	 constraint DefinirEstadoLampadaEQ ( dadoPresenca : DadosPresenca ) : ( comando : LampadaCmd ) {
	 	equation = (dadosPresenca.alguemPresente == true) ? 
	 	(comando == LampadaCmd::ligar_luzes) :
	 	(comando == LampadaCmd::desligar_luzes)
	 } component def ModuloPresencaCP { ports : qtndPessoa : QtndPessoasIPT ; presenca : AlguemPresenteIPT ; newPort : DadosPresencaOPT ; } component def ModuloControleACCP { ports : presencaIPT : DadosPresencaIPT ; comandoACOPT : ComandoACOPT ; temperaturaOPT : CelsiusOPT ; temperaturaIPT : CelsiusIPT ; }
	component def ModuloMonitoramentoACCP { ports : statusACIPT : StatusACIPT ; statusACOPT : StatusACOPT ; } } Requirement ProcessamentoVideoFR ( 1.3.2.1 ) { text = "O sistema deve ser capaz de processar um stream vídeo  para calcular o número de pessoas nele." derive ContarPessoasFR ; } Requirement ControlarArCondicionadoFR ( 1.1.1 ) { text = "O sistema deve ser capaz de ligar e desligar o ar-condicionado baseado nos dados de presença." derive GerenciarArCondicionadoFR ; } Requirement ControlarTemperaturaFR ( 1.1.3 ) { text = "O sistema deve ser capaz de definir a temperatura do ar-condicionado baseada no dado do leitor de temperatura." derive GerenciarArCondicionadoFR ; } Requirement GerenciarArCondicionadoFR ( 1.1 ) { text = "O sistema deve ser capaz de controlar o ar-condicionado." derive GerenciarLugarFR ; } Requirement GerenciarLuzesFR ( 1.2 ) { text = "O Sistema deve ser capaz de ligar e desligar as luzes baseados nos dados de presença." derive GerenciarLugarFR ; } Requirement DetectarPresencaFR ( 1.3.1 ) { text = "O sistema deve ser capaz de receber dados de um sensor de presença para detectar a presença de pessoas na sala." derive DetectarPessoasFR ; } Requirement ContarPessoasFR ( 1.3.2 ) { text = "O sistema deve ser capaz de receber e processar os dados de entrada de uma camera para contar a quantidade de pessoas na sala." derive DetectarPessoasFR ; } Requirement DetectarPessoasFR ( 1.3 ) { text = "O sistema deve ser capaz de  detectar a presença e contar a quantidade de pessoas na sala." derive GerenciarLugarFR ; } Requirement VerificarAparelhosFR ( 3.1 ) { text = "O sistema deve ser capaz de verificar o status do ar-condicionado." derive MonitoramentoWebFR ; } Requirement InterfaceWebFR ( 3.2 ) { text = "O sistema deve possuir uma interface web." derive MonitoramentoWebFR ; } Requirement ModificabilidadeNFR ( 2.2 ) { text = "O sistema deve ser extensível para novas formas de detecção de presença." derive QualidadeNFR ; } Requirement ModificabilidadeNFR ( 2.2.1 ) { text = "O sistema deve ser extensível para novas formas de detecção de presença." derive QualidadeNFR ; } Requirement ReceberVideoFR ( 1.3.2.2 ) { text = "O sistema deve ser capaz de receber um stream de video da camera." derive ContarPessoasFR ; }  Requirement LerTemperaturaFR ( 1.1.2 ) { text = "O sistema deve ser capaz de definir a temperatura do ar-condicionado a partir do leitor na sala." derive GerenciarArCondicionadoFR ; } Requirement LerLeitor ( 1.1.2.1 ) { text = "O sistema deve ser capaz de ler a temperatura em Celcius e Farenheit do leito na sala." derive LerTemperaturaFR ; }  style IoTStyle { invariant checkSensorCP = "self.checkCPRecursive(self, \'SensorCP\')" invariant checkDataStoreCP = "self.checkCPRecursive(self, \'DataStoreCP\')" invariant checkDeviceCP = "self.checkCPRecursive(self, \'DeviceCP\')" invariant checkSensorOPT = "self.checkPTRecursive(self, \'SensorOPT\')" invariant checkActuatorIPT = "not (self.checkCPRecursive(self, \'ActuatorCP\') xor self.checkPTRecursive(self, \'ActuatorIPT\'))" invariant checkDataIPT = "self.checkPTRecursive(self, \'DataIPT\')" invariant checkDataOPT = "self.checkPTRecursive(self, \'DataOPT\')" invariant checkServiceOPT = "not (self.checkCPRecursive(self, \'GatewayCP\') xor self.checkPTRecursive(self, \'ServiceOPT\'))" invariant checkDeviceIPT = "not (self.checkCPRecursive(self, \'GatewayCP\') xor self.checkPTRecursive(self, \'DeviceIPT\'))" invariant checkSensorDataCN = "self.checkCNRecursive(self, \'SensorDataCN\')" invariant checkDataStoreCN = "self.checkCNRecursive(self, \'DataStoreCN\')" invariant checkActuatorCommandCN = "not (self.checkCPRecursive(self, \'ActuatorCP\') xor self.checkCNRecursive(self, \'ActuatorCommandCN\'))" invariant checkServiceCN = "not (self.checkCPRecursive(self, \'GatewayCP\') xor self.checkCNRecursive(self, \'ServiceCN\'))" invariant checkDeviceDataCN = "not (self.checkPTRecursive(self, \'DeviceOPT\') xor self.checkCNRecursive(self, \'DeviceDataCN\'))" invariant ControllerMustBeEmbeddedInDevice = "self.ControllerCPEmbedded(self)" invariant SensorMustBeConnectedToDeviceOrController = "self.SensorConnection(self)" invariant ActuatorMustBeConnectedToDeviceOrController = "self.ActuatorConnection(self)" invariant SensorAndActuatorDontCommunicate = "self.Communication(self)" invariant SensorDataCNMustNotBeMultiplex = "self.checkBindingsRecursive(self, \'SensorDataCN\')" invariant ActuatorCommandCNMustNotBeMultiplex = "self.checkBindingsRecursive(self, \'ActuatorCommandCN\')" invariant DeviceDataCNMustNotBeMultiplex = "self.checkBindingsRecursive(self, \'DeviceDataCN\')" abstract component def SensorCP [ 1 , -1 ] { ports : SensorOPT : out any [ 1 , -1 ] } abstract component def ActuatorCP [ 0 , -1 ] { ports : ActuatorIPT : in any [ 1 , -1 ] } abstract component def DeviceCP [ 1 , -1 ] { ports : DeviceOPT : out any [ 0 , -1 ] SensorIPT : in any [ 0 , -1 ] ActuatorOPT : out any [ 0 , -1 ] ServiceIPT : in any [ 0 , -1 ] compose { SensorCP , ActuatorCP , ControllerCP , GatewayCP , DataStoreCP } } abstract component def DataStoreCP [ 1 , -1 ] { ports : DataOPT : out any [ 1 , -1 ] DataIPT : in any [ 1 , -1 ] } abstract component def ControllerCP [ 0 , -1 ] { ports : SensorIPT : in any [ 0 , -1 ] ActuatorOPT : out any [ 0 , -1 ] } abstract component def GatewayCP [ 0 , -1 ] { ports : DeviceIPT : in any [ 1 , -1 ] ServiceOPT : out any [ 1 , -1 ] ServiceIPT : in any [ 0 , -1 ] compose { DataStoreCP } } abstract component def IoTARCH { compose { SensorCP , ActuatorCP , DeviceCP , GatewayCP , DataStoreCP } } abstract connector def SensorDataCN { participants : ~ SensorOPT : out any ~ SensorIPT : in any flows : flow SensorOPT to SensorIPT } abstract connector def ActuatorCommandCN { participants : ~ ActuatorOPT : out any ~ ActuatorIPT : in any flows : flow ActuatorOPT to ActuatorIPT } abstract connector def DeviceDataCN { participants : ~ DeviceOPT : out any ~ DeviceIPT : in any flows : flow DeviceOPT to DeviceIPT } abstract connector def DataStoreCN { participants : ~ DataOPT : out any ~ DataIPT : in any flows : flow DataOPT to DataIPT } abstract connector def ServiceCN { participants : ~ ServiceOPT : out any ~ ServiceIPT : in any flows : flow ServiceOPT to ServiceIPT } abstract activity def Monitoring abstract activity def Analysis abstract activity def Planning abstract activity def Execution } style PipesFilters { invariant OnlyPipesConnectsFilters = "self.connectors->forall(cn | cn.definition.abstractConnector.name<>\'APipe\' or (cn.definition.abstractConnector.name=\'APipe\' and (checkPortUseAbstractComponent(cn.bindings->first().destination,\'AFilter\') and checkPortUseAbstractComponent(cn.bindings->first().source, \'AFilter\'))))" abstract connector def APipe { } abstract component def AFilter { } } style ClientServer { invariant ClientMustConnectToServer = "self.ExistsConnectionForAll(\'AClient\', \'AServer\')" invariant ClientShouldntConnectToClient = "not(self.ExistsConnection(\'AClient\', \'AClient\'))" abstract component def AClient { } abstract component def AServer { } }